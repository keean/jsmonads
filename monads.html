<!DOCTYPE html>
<html lang="en">
<head>
    <title>Monads in JavaScript</title>
</head>
<body>
<div id="display" style="white-space:pre-wrap"></div>
<script>
    var show_obj = function(o) {
        var s = '{\n';
        for (p in o) {
            s += '\t' + p + ': ' + o[p] + ',\n';
        }
        s += '}\n';
        document.getElementById('display').textContent += s;
    };

    var equal = function(a1, a2) {
        var l1 = a1.length;
        var l2 = a2.length;
        if (l1 !== l2) {return false;}
        var same = true;
        for (var i = 0; i < l1; i++) {
            if (a1[i] !== a2[i]) {
                same = false;
                break;
            }
        }
        return same;
    }
                        
    var test = function(t, b) {
        if (b) {
            t += " test passed.\n";
        } else {
            t += " test failed.\n";
        }

        document.getElementById('display').textContent += t;
    };

    var test_laws = function(name, unit) {
        var f = function(x) {return unit(2 * x);};
        var g = function(x) {return unit(x + 3);};
        var h = function(x) {return 2 * x.extract();};
        var i = function(x) {return x.extract() + 3;};

        // Monad Laws
        //
        //  (bind (unit a) f)  == (f a)
        //  (bind m unit) == m
        //  (bind (bind m f) g) == (bind m (\x -> bind (f x) g))

        if (unit(1).bind !== undefined) {
            unit(1).bind(f).bind(function (x) {
                f(1).bind(function (y) {
                    test(name + " Monad Left Identity ", x === y);
                    return unit();
                }).run();
                return unit();
            }).run();
            unit(1).bind(unit).bind(function(x) {
                test(name + " Monad Right Identity", x === 1);
                return unit();
            }).run();
            unit(1).bind(f).bind(g).bind(function(x) {
                unit(1).bind(function(x) {return f(x).bind(g);}).bind(function(y) {
                    test(name + " Monad Associativity", x === y);
                    return unit();
                }).run();
                return unit();
            }).run();
        } 

        // Comonad Laws
        //
        // (extend (extract)) == id
        // (extract (extend f) == f
        // (extend g (extend f)) == extend(f(extend g))

        if ((unit(1).extract !== undefined) && (unit(1).extend !== undefined)) {
            test(name + " Comonad Left Identity", unit(1).extend(comonad.extract).extract() === 1);
            test(name + " Comonad Right Identity", unit(1).extend(h).extract() ===  h(unit(1)));
            test(name + " Comonad Associativity", unit(1).extend(i).extend(h).extract() === unit(1).extend(function(a) {return h(a.extend(i));}).extract());
            var n = unit(1);
            var m = unit(2);
            test(name + " Comonad Scope", n.extract(), 1);
        }

        // MonadPlus Laws
        //
        // (plus zero m) == m
        // (plus m zero) == m
        // (plus m (plus n o)) == (plus (plus m n) o)

        if ((unit(1).zero !== undefined) && (unit(1).plus !== undefined)) {
            unit().plus(unit(1)).bind(function(x) {
                test(name + " MonadPlus Left Identity", x === 1);
                return unit();
            }).run();
            unit(1).plus(unit()).bind(function(x) {
                test(name + " MonadPlus Right Identity", x === 1);
                return unit();
            }).run();
            var a1 = [];
            var a2 = [];
            unit().plus(unit(1).plus(unit(2))).bind(function(x) {
                a1 += x;
                return unit();
            }).run();
            unit().plus(unit(1)).plus(unit(2)).bind(function(y) {
                a2 += y;
                return unit();
            }).run();
            test(name + " MonadPlus Associativity", equal(a1, a2));
        }
    };

    //------------------------------------------------------------------------
    // Polymorphic functions

    var id = function(x) {return x};

    //  class Functor m where
    //      fmap :: (a -> b) -> f a -> f b
    //
    var functor = {
        fmap: function(m) {
            return function(f) {
                return m.fmap(f);
            }
        }
    };

    //  class Monad m where
    //      unit :: a -> m a
    //      bind :: m a -> (a -> m b) -> m b
    //
    var monad = {
        bind: function(m) {
            return function(f) {
                return m.bind(f);
            }
        },
        join: function(m) {
            return function(n) {
                return m.join(n);
            }
        }
    };

    //  class Comonad w where
    //      extract :: w a -> a
    //      extend :: w a -> (w a -> b) -> w b
    //
    var comonad = {
        extend: function(m) {
            return function(f) {
                return m.extend(f);
            }
        },
        extract: function(m) {
            return m.extract();
        }
    };

    //  class MonadPlus m where
    //      zero :: m a
    //      plus :: m a -> m a -> m a
    //
    var monad_plus = {
        zero: function() {
            return monad.unit();
        },
        plus: function(m) {
            return function (n) {
                return m.plus(n);
            }
        }
    };

    //  class MonadCont where
    //      callcc :: ((a -> (forall b. m b)) -> m a) -> m a
    //
    var monad_cont = {
        callcc: function(m) {
            return function (f) {
                return m.callcc(f);
            }
        }
    };

    //------------------------------------------------------------------------
    // Identity Monad
    //
    // implements: functor monad comonad

    var identity = function(value) {
        return {
            run: function() {
                return value;
            },

            fmap: function(f) {
                value = f(value);
                return this;
            },

            unit: function(v) {
                value = v;
                return this;
            },
            bind: function(f) {
                return f(value);
            },

            extract: function() {
                return value;
            },
            extend: function(f) {
                value = f(this);
                return this;
            }
        };
    };

    identity.unit = identity;

    test_laws("Identity", identity.unit);

    //------------------------------------------------------------------------
    // Maybe Monad: note unit() is used for zero.
    //
    // implements: functor monad monad_plus

    var maybe = function(value) {
        return {
            run: function() {
                return value;
            },

            fmap: function(f) {
                if (value !== undefined) {value = f(value);}
                return this;
            },

            unit: function(v) {
                value = v;
                return this;
            },
            bind: function(f) {
                if (value !== undefined) {return f(value);} 
                return this;
            },


            zero: function() {
                value = undefined;
                return this;
            },
            plus: function(m) {
                if (value !== undefined) {return this;}
                return m;
            }
        };
    };

    maybe.unit = maybe;

    test_laws("Maybe", maybe.unit);

    //------------------------------------------------------------------------
    // Either Monad
    //
    // implements: functor monad monad_plus

    var either = function(is_right, value) {
        return {
            run: function() {
                return {is_right:is_right, value:value};
            },

            fmap: function(f) {
                if (is_right) {value = f(value);}
                return this;
            },

            unit: function(v) {
                is_right = (v !== undefined);
                value = v;
                return this;
            },
            bind: function(f) {
                return is_right ? f(value) : this;
            },

            zero: function() {
                is_right = false;
                value = undefined;
                return this;
            },
            plus: function(m) {
                return is_right ? this : m;
            }
        };
    };

    either.unit = function(v) {return either(v !== undefined, v);};

    test_laws("Either", either.unit);

    //------------------------------------------------------------------------
    // List Monad
    //
    // implements: functor monad comonad monad_plus

    var list = function(value) {
        return {
            run: function() {
                return value;
            },

            fmap: function(f) {
                for (var i = 0; i < value.length; i++) {
                    value[i] = f(value[i]);
                }
                return this;
            },

            unit: function(u) {
                value = (u === undefined) ? [] : [u];
                return this;
            },
            bind: function(f) {
                var new_value = [];
                for (var i = 0; i < value.length; i++) {
                    f(value[i]).bind(function(x) {
                        new_value = new_value.concat(x);
                        return list([]);
                    });
                }
                value = new_value;
                return this;
            },

            extract: function() {
                return value[0];
            },
            extend: function(f) {
                var new_value = [];
                var l = value.length;
                for(var i = 0; i < l; i++) {
                    new_value.push(f(this));
                    value.pop();
                }
                value = new_value;
                return this;
            },

            zero: function() {
                value = [];
                return this;
            },
            plus: function(m) {
                m.bind(function(x) {
                    value = value.concat(x);
                    return list([]);
                });
                return this;
            }
        };
    };

    list.unit = function(v) {return list((v === undefined) ? [] : [v]);};

    test_laws("List", list.unit);

    //------------------------------------------------------------------------
    // Continuation Monad
    //
    // implements: functor monad monad_cont 

    var continuation = function(value) {
        return {
            run: function(k) {
                return value(k || id);
            },

            fmap: function(f) {
                value = (function(v) {
                    return function(k) {
                        return v(function(a) {
                            return k(f(a));
                        });
                    };
                })(value);
                return this;
            },

            unit: function(u) {
                value = function(k) {return k(u);};
                return this;
            },
            bind: function(f) { 
                value = (function(v) {
                    return function(k) {
                        return v(function(a) {
                            return f(a).run(k);
                        });
                    };
                })(value);
                return this;
            },

            callcc: function(f) {
                value = function(k) {
                    return f(k).run(k);
                };
                return this;
            },
            // when
            shift: function(e) {
                value = function(k) {
                    return e(function(a) {
                        return this.unit(k(a));
                    }).run(id);
                };
            },
            reset: function(e) {
                return e.run(id);
            }
        };
    };

    continuation.unit = function(u) {return continuation(function(k) {return k(u);});};

    test_laws("Continuation", continuation.unit);

    var m = continuation.unit("1");
    test("Continuation CallCC", m.bind(function(x) {
        return m.callcc(function(k) {return m.unit("2");}).bind(function(y) {
            return m.unit(x + "+" + y);
        });
    }).fmap(function(x) {return "A" + x;}).run(id) === "A1+2");


    var m = continuation.unit("2");
    m.bind(function(x) {
        return m.callcc(function(k) {setTimeout(function() {k("4")}, 1000); return continuation.unit("3");}).bind(function(y) {
            return m.unit(x + "+" + y);
        });
    }).fmap(function(x) {return "A" + x;}).bind(function(x) {
        if (x === "A2+3") {
            document.getElementById('display').textContent += "Continuation CallCC immediate test passed\n";
        } else if (x === "A2+4") {
            document.getElementById('display').textContent += "Continuation CallCC callback test passed\n";
        } else {
            document.getElementById('display').textContent += "Continuation CallCC imediate/callback failed\n";
        }
        return m.unit();
    }).run(id);

    var m = continuation().unit("3");
    m.bind(function(x) {return m.callcc(function(k) {setTimeout(function() {k("5" + x)}, 500); return m.unit("7" + x);});});
    m.bind(function(x) {return m.callcc(function(k) {setTimeout(function() {k("6" + x)}, 1000); return m.unit("8" + x);});});
    m.fmap(function(x) {return "A" + x;});
    m.bind(function(x) {
        if (x === "A873") {
            document.getElementById('display').textContent += "Continuation CallCC imm, imm test passed\n";
        } else if (x === "A853") {
            document.getElementById('display').textContent += "Continuation CallCC cb, imm test passed\n";
        } else if (x === "A673") {
            document.getElementById('display').textContent += "Continuation CallCC imm, cb test passed\n";
        } else if (x === "A653") {
            document.getElementById('display').textContent += "Continuation CallCC cb, cb test passed\n";
        } else {
            document.getElementById('display').textContent += "Continuation CallCC imm/cb, imm/cb test failed\n";
        }
        return m.unit();
    });
    m.run(id);

</script>
</body>
</html>
